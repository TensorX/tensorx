# -*- coding: utf-8 -*-
from __future__ import print_function
from __future__ import unicode_literals

import re
import inspect
import os
import shutil
import six
import yaml

try:
    import pathlib
except ImportError:
    import pathlib2 as pathlib

import tensorx

from mako.template import Template

import sys

root = pathlib.Path(__file__).resolve().parents[1]
docstring_template = os.path.join(os.path.dirname(__file__), 'docstring_template.md')
markdown_template = Template(filename=docstring_template)

from docs.parse import GoogleDocString
from docs.parse import Extract


def class_to_source_link(cls):
    module_name = cls.__module__
    path = module_name.replace('.', '/')
    path += '.py'
    line = inspect.getsourcelines(cls)[-1]
    link = ('https://github.com/davidenunes/'
            'tensorx/blob/master/' + path + '#L' + str(line))
    return '[[source]](' + link + ')'


def count_leading_spaces(s):
    ws = re.search(r'\S', s)
    if ws:
        return ws.start()
    else:
        return 0


def get_module_docstring(filepath):
    """Extract the module docstring.

    Also finds the line at which the docstring ends.
    """
    co = compile(open(filepath, encoding='utf-8').read(), filepath, 'exec')
    if co.co_consts and isinstance(co.co_consts[0], six.string_types):
        docstring = co.co_consts[0]
    else:
        print('Could not get the docstring from ' + filepath)
        docstring = ''
    return docstring, co.co_firstlineno


def copy_examples(examples_dir, destination_dir):
    """Copy the examples directory in the documentation.

    Prettify files by extracting the docstrings written in Markdown.
    """
    pathlib.Path(destination_dir).mkdir(exist_ok=True)
    for file in os.listdir(examples_dir):
        if not file.endswith('.py'):
            continue
        module_path = os.path.join(examples_dir, file)
        docstring, starting_line = get_module_docstring(module_path)
        destination_file = os.path.join(destination_dir, file[:-2] + 'md')
        with open(destination_file, 'w+', encoding='utf-8') as f_out, \
                open(os.path.join(examples_dir, file),
                     'r+', encoding='utf-8') as f_in:

            f_out.write(docstring + '\n\n')

            # skip docstring
            for _ in range(starting_line):
                next(f_in)

            f_out.write('```python\n')
            # next line might be empty.
            line = next(f_in)
            if line != '\n':
                f_out.write(line)

            # copy the rest of the file.
            for line in f_in:
                f_out.write(line)
            f_out.write('```')


def to_markdown(target_info):
    docstring = target_info['docstring']
    parser = GoogleDocString(docstring)
    try:
        parser.parse()
    except SyntaxError as e:
        e2 = f"Error while processing docstrings for {target_info['class']}.{target_info['function']}"
        raise Exception(e2+":\n\t"+str(e)).with_traceback(e.__traceback__)

    headers, data = parser.markdown()

    # if docstring contains a signature, override the source
    if "signature" in data[0]:
        signature = data[0]["signature"]
    else:
        signature = target_info['signature']

    # print(class_info)

    # in mako ## is a comment
    markdown_str = markdown_template.render(header=target_info,
                                            signature=signature,
                                            sections=data,
                                            headers=headers,
                                            h2='##', h3='###')

    return markdown_str


def generate(sources_dir):
    """Generates the markdown files for the documentation.

    # Arguments
        sources_dir: Where to put the markdown files.
    """
    template_dir = os.path.join(str(root), 'docs', 'templates')
    print("Loading configuration file")
    config_path = os.path.join(str(root), 'docs', 'config.yaml')
    config = yaml.full_load(open(config_path))

    print('Cleaning up existing sources directory.')
    if os.path.exists(sources_dir):
        shutil.rmtree(sources_dir)

    print('Populating sources directory with templates.')
    shutil.copytree(template_dir, sources_dir)

    readme = open(os.path.join(str(root), 'README.md')).read()
    index = open(os.path.join(template_dir, 'index.md')).read()
    index = index.replace('{{autogenerated}}', readme[readme.find('##'):])
    with open(os.path.join(sources_dir, 'index.md'), 'w', encoding='utf-8') as f:
        f.write(index)

    print("Generating docs ...")

    for page_data in config['pages']:
        page_template = page_data['page']
        source = os.path.join(root, page_data['source'])
        extract = Extract(source)

        markdown_docstrings = []
        classes = page_data.get('classes', [])
        methods = page_data.get('methods', [])
        functions = page_data.get('functions', [])

        for class_name in classes:
            target_info = extract.get_class(class_name)
            markdown_str = to_markdown(target_info)
            markdown_docstrings.append(markdown_str)

            methods = extract.get_methods(class_name)
            if methods:
                markdown_docstrings[-1] += "\n\n**Methods:**\n\n"
                for method in methods:
                    try:
                        method_info = extract.get_method(class_name=class_name,
                                                         method_name=method)
                        markdown_str = to_markdown(method_info)
                        markdown_docstrings[-1] += markdown_str
                    except NameError:
                        pass

        # print(page_data.get('methods', []))
        for class_dict in methods:
            for c, ms in class_dict.items():
                for m in ms:
                    print(f"Generating docs for {c}.{m}")
                    method_info = extract.get_method(class_name=c,
                                                     method_name=m)
                    markdown_str = to_markdown(method_info)
                    markdown_docstrings.append(markdown_str)

        for fn in functions:
            print(f"Generating docs for {fn}")
            fn_info = extract.get_function(fn)
            markdown_str = to_markdown(fn_info)
            markdown_docstrings.append(markdown_str)
        #    for method name in class_name:

        markdown = '\n----\n\n'.join(markdown_docstrings)

        # Either insert content into existing template or create new page
        page_name = page_data['page']
        path = os.path.join(sources_dir, page_name)
        if os.path.exists(path):
            page_template = open(path).read()

            if '{{autogenerated}}' not in page_template:
                raise RuntimeError('Template found for ' + path +
                                   ' but missing {{autogenerated}}'
                                   ' tag.')
            markdown = page_template.replace('{{autogenerated}}', markdown)
            print('...inserting autogenerated content into template:', path)
        else:
            print('...creating new page with autogenerated content:', path)
        subdir = os.path.dirname(path)
        if not os.path.exists(subdir):
            os.makedirs(subdir)
        with open(path, 'w', encoding='utf-8') as f:
            f.write(markdown)

    shutil.copyfile(os.path.join(str(root), 'CONTRIBUTING.md'),
                    os.path.join(str(sources_dir), 'contributing.md'))
    copy_examples(os.path.join(str(root), 'examples'),
                  os.path.join(str(sources_dir), 'examples'))


if __name__ == '__main__':
    generate(os.path.join(str(root), 'docs', 'sources'))
